-- libt can be invoked as a script to force
-- clean the modules cache.
local args = {...}
local forceReload = args[1]

-- Initialize the T module
local t = {}

-- | The version of libt
t.VERSION = { 0, 0, 2, 0 }

-- Initialize the modules cache
if libtmodules == nil or forceReload then
  _G['libtmodules'] = {
    t = t
  }
else
  return libtmodules.t
end

-- | Produces a table of the keys in a
-- table.
function t.keys(tab)
  local result = {}
  for k, _ in pairs(tab) do
    table.insert(result, k)
  end
  return result
end

-- | Creates an iterator for the keys in a
-- table
function t.ikeys(tab)
  return t.imap(
    pairs(tab),
    function(_, v)
      return v
    end
  )
end

-- | Creates a new table by running a
-- function on each element of a table.
function t.map(array, func)
  local result = {}
  for _, v in ipairs(array) do
    table.insert(result, func(v))
  end
  return result
end

-- | Maps a function inside an iterator.
function t.imap(it, func)
  return function()
    local x = {it()}
    if x[1] == nil then
      return nil
    else
      return func(unpack(x))
    end
  end
end

-- | Creates a new table containing only the
-- elements satisfying a predicate.
function t.filter(array, func)
  local result = {}
  for _, v in ipairs(array) do
    if func(v) then
      table.insert(result, v)
    end
  end
  return result
end

-- | Drops elements from an iterator unless
-- they satisfy a predicate.
function t.ifilter(it, func)
  return function()
    local x = nil
    while x == nil do
      x = it()
      if x == nil then
        return nil
      elseif func(x) then
        return x
      else
        x = nil
      end
    end
  end
end

-- | Construct an iterator from an array.
function t.from(array)
  local i = 1
  return function()
    if i <= #array then
      local x = array[i]
      i = i + 1
      return x
    else
      return nil
    end
  end
end

-- | Construct an array from an iterator.
function t.consume(it)
  local result = {}
  for x in it do
    table.insert(result, x)
  end
  return result
end

-- | Iterate over the tokens in a string
-- that result by separating by any of the
-- characters in `sep`.
function t.splitBy(str, sep)
  return string.gmatch(str, "[^"..sep.."]")
end

-- | Iterate over the tokens in a string
-- that result by separating by one or more
-- whitespace characters
function t.spaceSplit(str)
  return string.gmatch(str, "(%S+)")
end

function compose(i, fns)
  if i == #fns then
    return fns[i]
  else
    return function(x)
      return fns[i](compose(i+1, fns)(x))
    end
  end
end

-- | Right-to-left composition of functions.
-- The functions must all be unary.
function t.c(...)
  return compose(1, arg)
end

-- | Loads a T module.
-- Does not account for circular imports, so
-- don't make cycles!
function t.require(name)
  local m = libtmodules[name]
  if m == nil then
    local f = loadfile(name)
    if f == nil then
      m = nil
    else
      m = f()
      libtmodules[name] = m
    end
  end
  return m
end

function t.extend(tab1, tab2)
  for _, v in ipairs(tab2) do
    table.insert(tab1, v)
  end
end

return t

-- vim: ft=lua shiftwidth=2 expandtab colorcolumn=45 tw=44

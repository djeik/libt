local t = loadfile("libt")()
  or error("failed to load libt")

local tmsg = {}

-- don't requireStrict because libtmsg can be
-- used without JSON support
local json = t.require("libjson")

tmsg.VERSION = { 0, 0, 1, 0 }

tmsg.CONNECTION = {
    HOST = "localhost",
    PORT = 8080,
    PREFIX = "",
}

local function mkUrl(id)
  return "http://" ..
  tmsg.CONNECTION.HOST .. ":" ..
  tostring(tmsg.CONNECTION.PORT) ..
  tmsg.CONNECTION.PREFIX .. id
end

tmsg.CONTENT_TYPE = {
  PLAIN_TEXT = "text/plain; charset=utf-8",
  JSON = "application/json",
  ANY = "*/*",
}

function tmsg.send(id, msg, contentType, accept)
  local contentType = contentType
    or tmsg.CONTENT_TYPE.PLAIN_TEXT
  local accept = accept
    or tmsg.CONTENT_TYPE.ANY

  local headers = {}
  headers["Content-type"] = contentType
  headers["Accept"] = accept
  local result = http.post(mkUrl(id), msg, headers)
  if result == nil then
    return nil
  end
  return result.readAll()
end

function tmsg.recv(id)
  local result = http.get(mkUrl(id), { Accept = "*/*" })
  if result == nil then
    return nil
  end
  local f = result.readAll()
  if f == "" then
    return nil
  end
  return f
end

function tmsg.sendLua(id, tab)
  return tmsg.send(id, t.show(tab))
end

function tmsg.recvLua(id)
  return t.read(tmsg.recv(id))
end

if json ~= nil then
  function tmsg.sendJSON(id, data, parse)
    local result = tmsg.send(
      id,
      json:encode(data),
      tmsg.CONTENT_TYPE.JSON,
      tmsg.CONTENT_TYPE.JSON
    )

    if parse then
      return json:decode(result)
    else
      return result
    end
  end

  function tmsg.recvJSON(id)
    return json:decode(tmsg.recv(id))
  end
end

return tmsg

-- vim: ft=lua shiftwidth=2 expandtab colorcolumn=45
